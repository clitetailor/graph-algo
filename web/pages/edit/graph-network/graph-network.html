<svg
  bind:this="{svg}"
  width="100%"
  height="100%"
  on:mousedown="{onSvgMouseDown}"
  on:mousemove="{onSvgMouseMove}"
  on:mousewheel="{onSvgMouseWheel}"
  on:click="{onSvgClick}"
  class="c-graph-network__layout"
>
  <defs>
    <marker
      id="c-graph-network__arrow"
      viewBox="0 0 10 10"
      refX="10"
      refY="5"
      markerWidth="6"
      markerHeight="6"
      orient="auto-start-reverse"
    >
      <path d="M 0 0 L 10 5 L 0 10 z" />
    </marker>
    <marker
      id="c-graph-network__arrow--selected"
      viewBox="0 0 10 10"
      refX="10"
      refY="5"
      markerWidth="6"
      markerHeight="6"
      orient="auto-start-reverse"
    >
      <path
        class="c-arrow is-selected"
        d="M 0 0 L 10 5 L 0 10 z"
      />
    </marker>
    <marker
      id="c-graph-network__curve-arrow"
      viewBox="0 0 10 10"
      refX="10"
      refY="5"
      markerWidth="6"
      markerHeight="6"
      orient="auto-start-reverse"
    >
      <path d="M 0 0 L 10 5 L 0 10 z" />
    </marker>
    <marker
      id="c-graph-network__curve-arrow--selected"
      viewBox="0 0 10 10"
      refX="10"
      refY="5"
      markerWidth="6"
      markerHeight="6"
      orient="auto-start-reverse"
    >
      <path
        class="c-arrow is-selected"
        d="M 0 0 L 10 5 L 0 10 z"
      />
    </marker>
  </defs>
  <g transform="translate({offsetX}, {offsetY}) scale({scale})">
    <g class="c-graph-network__edges">
      {#each graph.edges as edge} {#if edge.bidirect}
      <path
        d="{curve(edge)}"
        marker-end="url(#c-graph-network__curve-arrow{isMarkerSelected(edge)})"
        data-source-id="{edge.source.id}"
        data-target-id="{edge.target.id}"
        class:is-selected="{edge.selected}"
        on:click="{onEdgeClick(edge)}"
      ></path>
      {:else}
      <path
        d="{line(edge)}"
        marker-end="url(#c-graph-network__arrow{isMarkerSelected(edge)})"
        data-source-id="{edge.source.id}"
        data-target-id="{edge.target.id}"
        class:is-selected="{edge.selected}"
        on:click="{onEdgeClick(edge)}"
      ></path>
      {/if} {/each}
    </g>
    <g class="c-graph-network__nodes">
      {#each graph.nodes as node}
      <g
        data-node-id="{node.id}"
        class:is-selected="{node.selected}"
        on:click="{onNodeClick(node)}"
        on:mousedown="{onNodeMouseDown(node)}"
      >
        <circle
          cx="{node.x}"
          cy="{node.y}"
          r="{radius}"
        ></circle>
        <text
          x="{node.x}"
          y="{node.y}"
          text-anchor="middle"
          alignment-baseline="middle"
        >
          {node.id}
        </text>
      </g>
      {/each}
    </g>
  </g>
</svg>

<svelte:options accessors></svelte:options>

<style>
  svg text {
    user-select: none;
  }

  .c-graph-network__nodes circle {
    stroke: black;
    stroke-width: 2px;
    fill: white;
  }

  .c-graph-network__nodes text {
    font-family: Arial, Helvetica, sans-serif;
    fill: black;
  }

  .c-graph-network__nodes .is-selected circle {
    stroke: orange;
  }

  .c-graph-network__nodes circle:hover {
    cursor: pointer;
  }

  .c-graph-network__nodes .is-selected text {
    fill: orange;
  }

  .c-graph-network__edges path,
  .c-graph-network__edges line {
    stroke: black;
    stroke-width: 2px;
    fill: transparent;
  }

  .c-graph-network__edges path:hover,
  .c-graph-network__edges line:hover {
    cursor: pointer;
  }

  .c-graph-network__edges .is-selected {
    stroke: orange;
  }

  .c-arrow.is-selected {
    fill: orange;
  }
</style>

<script>
  import { onMount, onDestroy, beforeUpdate } from 'svelte'
  import * as d3 from 'd3'

  import { createSimulation } from './simulation'
  import { seedNodes } from './seed'

  export let offsetX = 0
  export let offsetY = 0
  export let scale = 1

  let svg
  const radius = 20

  export let graph = {
    nodes: [],
    edges: []
  }
  const selected = {
    nodes: [],
    edges: []
  }

  let simulation
  let nodeCounter = 0

  let noop = () => {}

  export let onSvgMouseDown = noop
  export let onSvgMouseMove = noop
  export let onSvgClick = noop
  export let onSvgMount = noop
  export let onSvgMouseWheel = noop

  export let onNodeClick = () => noop
  export let onNodeMouseDown = () => noop

  export let onEdgeClick = () => noop

  onMount(() => {
    simulation = createSimulation({
      width: svg.clientWidth,
      height: svg.clientHeight,
      radius
    })
    simulation.nodes(graph.nodes)
    simulation.force('link').links(graph.edges)

    simulation.on('tick', () => {
      graph.nodes = graph.nodes
      graph.edges = graph.edges
    })

    onSvgMount()
  })

  export function setNodes(nodes) {
    for (const node of nodes) {
      node.count = 0
    }

    graph.nodes = nodes
    graph.edges = []
    resetNodeCounter()
  }

  export function setEdges(edges) {
    for (const edge of edges) {
      edge.source.count += 1
      edge.target.count += 1

      const reverseEdge = graph.edges.find(
        e =>
          e.target.id === edge.source.id &&
          e.source.id === edge.target.id
      )

      if (reverseEdge) {
        reverseEdge.bidirect = true
        edge.bidirect = true
      }
    }

    graph.edges = edges
  }

  export function restartSimulation(alpha = 1) {
    simulation.nodes(graph.nodes)
    simulation.force('link').links(graph.edges)
    simulation.alpha(alpha)
    simulation.restart()
  }

  export function resetNodeCounter() {
    nodeCounter = graph.nodes.reduce(
      (prev, node) => (node.id > prev ? node.id : prev),
      0
    )
  }

  export function getWidth() {
    return svg.clientWidth
  }

  export function getHeight() {
    return svg.clientHeight
  }

  function normalize(vec) {
    const dist = Math.sqrt(vec.x * vec.x + vec.y * vec.y)

    return {
      x: vec.x / dist,
      y: vec.y / dist
    }
  }

  function line(edge) {
    const source = {}
    const target = {}

    const distVec = {
      x: edge.target.x - edge.source.x,
      y: edge.target.y - edge.source.y
    }
    const normVec = normalize(distVec)

    source.x = edge.source.x + normVec.x * radius
    source.y = edge.source.y + normVec.y * radius

    target.x = edge.target.x - normVec.x * radius
    target.y = edge.target.y - normVec.y * radius

    return `
      M ${source.x} ${source.y}
      L ${target.x} ${target.y}
    `
  }

  function rotate(vec, angle) {
    const radian = (angle / 180) * Math.PI
    return {
      x: vec.x * Math.cos(radian) - vec.y * Math.sin(radian),
      y: vec.x * Math.sin(radian) + vec.y * Math.cos(radian)
    }
  }

  function mulitply(vec, number) {
    return {
      x: vec.x * number,
      y: vec.y * number
    }
  }

  function curve(edge) {
    const source = {}
    const mid = {}
    const target = {}

    const normVec = normalize({
      x: edge.target.x - edge.source.x,
      y: edge.target.y - edge.source.y
    })

    const multiplied = mulitply(normVec, radius)
    const leftRadian = rotate(multiplied, 20)
    const rightRadian = rotate(multiplied, 160)

    source.x = edge.source.x + leftRadian.x
    source.y = edge.source.y + leftRadian.y

    target.x = edge.target.x + rightRadian.x
    target.y = edge.target.y + rightRadian.y

    const prepVec = rotate(mulitply(multiplied, 1.5), 90)

    mid.x = (source.x + target.x) / 2 + prepVec.x
    mid.y = (source.y + target.y) / 2 + prepVec.y

    return `
      M ${source.x} ${source.y}
      Q
        ${mid.x}
        ${mid.y}
        ${target.x} ${target.y}
    `
  }

  function isNodeValid(node) {
    return true
    /*
    (
      node.x !== undefined &&
      node.y !== undefined &&
      !isNaN(node.x) &&
      !isNaN(node.y)
    )
    */
  }

  function isEdgeValid(edge) {
    return true
    /*
    (
      edge.source &&
      isNodeValid(edge.source) &&
      edge.target &&
      isNodeValid(edge.target)
    )
    */
  }

  function isMarkerSelected(edge) {
    if (edge.selected) {
      return '--selected'
    }

    return ''
  }

  export function createNodeAt(x, y) {
    nodeCounter = nodeCounter + 1
    graph.nodes.push({
      id: nodeCounter,
      count: 0,
      x,
      y
    })
    graph.nodes = graph.nodes

    restartSimulation()
  }

  export function createEdge(sourceNode, targetNode) {
    if (
      !graph.edges.find(
        edge =>
          edge.source.id === sourceNode.id &&
          edge.target.id === targetNode.id
      )
    ) {
      const reverseEdge = graph.edges.find(
        e =>
          e.source.id === targetNode.id &&
          e.target.id === sourceNode.id
      )

      sourceNode.count += 1
      targetNode.count += 1

      const edge = {
        id: `${sourceNode.id}-${targetNode.id}`,
        source: sourceNode,
        target: targetNode
      }

      if (reverseEdge) {
        edge.bidirect = true
        reverseEdge.bidirect = true
      }

      graph.edges.push(edge)
      graph.edges = graph.edges
      restartSimulation()
    }
  }

  export function selectNode(node) {
    if (!node.selected) {
      node.selected = true
      selected.nodes.push(node)
      graph.nodes = graph.nodes
    }
  }

  export function getSelectedNodes() {
    return selected.nodes
  }

  export function selectEdge(edge) {
    edge.selected = true
    selected.edges.push(edge)
    graph.edges = graph.edges
  }

  export function getSelectedEdges() {
    return selected.edges
  }

  export function clearNodeSelections() {
    for (const node of selected.nodes) {
      node.selected = undefined
    }
    selected.nodes = []
    graph.nodes = graph.nodes
  }

  export function clearEdgeSelections() {
    for (const edge of selected.edges) {
      edge.selected = undefined
    }
    selected.edges = []
    graph.edges = graph.edges
  }

  export function clearSelections() {
    clearNodeSelections()
    clearEdgeSelections()
  }

  export function removeNode(node) {
    const nodeIndex = graph.nodes.indexOf(node)
    if (nodeIndex !== -1) {
      graph.nodes.splice(nodeIndex, 1)
      graph.nodes = graph.nodes

      graph.edges = graph.edges.filter(
        e => e.source.id !== node.id && e.target.id !== node.id
      )
      graph.edges = graph.edges

      restartSimulation()
    }
  }

  export function removeEdge(edge) {
    const edgeIndex = graph.edges.indexOf(edge)
    if (edgeIndex !== -1) {
      const reverseEdge = graph.edges.find(
        e =>
          e.source.id === edge.target.id &&
          e.target.id === edge.source.id
      )

      if (reverseEdge) {
        reverseEdge.bidirect = false
      }

      graph.edges.splice(edgeIndex, 1)
      graph.edges = graph.edges
      restartSimulation()
    }
  }

  export function getBoundingClientRect() {
    return svg.getBoundingClientRect()
  }

  export function isActive() {
    return simulation.alpha() > simulation.alphaMin()
  }

  export function update() {
    graph = graph
  }
</script>
