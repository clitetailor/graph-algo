<svg
  bind:this="{svg}"
  width="100%"
  height="100%"
  on:mousedown="{onSvgMouseDown}"
  on:mousemove="{onSvgMouseMove}"
  on:mousewheel="{onSvgMouseWheel}"
  on:click="{onSvgClick}"
  class="c-graph-network__layout"
>
  <defs>
    <marker
      id="c-graph-network__arrow"
      viewBox="0 0 10 10"
      refX="{radius + 5}"
      refY="5"
      markerWidth="6"
      markerHeight="6"
      orient="auto-start-reverse"
    >
      <path d="M 0 0 L 10 5 L 0 10 z" />
    </marker>
    <marker
      id="c-graph-network__curve-arrow"
      viewBox="0 0 10 10"
      refX="{radius + 5}"
      refY="5"
      markerWidth="6"
      markerHeight="6"
      orient="auto-start-reverse"
    >
      <path d="M 0 0 L 10 5 L 0 10 z" />
    </marker>
  </defs>
  <g transform="translate({offsetX}, {offsetY}) scale({scale})">
    <g class="c-graph-network__edges">
      {#each graph.edges as edge (edge.id)} {#if edge.bidirect}
      <path
        d="{curve(edge)}"
        marker-end="url(#c-graph-network__curve-arrow)"
        data-source-id="{edge.source.id}"
        data-target-id="{edge.target.id}"
        class:is-selected="{edge.selected}"
        on:click="{onEdgeClick(edge)}"
      ></path>
      {:else}
      <line
        x1="{edge.source.x}"
        y1="{edge.source.y}"
        x2="{edge.target.x}"
        y2="{edge.target.y}"
        marker-end="url(#c-graph-network__arrow)"
        data-source-id="{edge.source.id}"
        data-target-id="{edge.target.id}"
        class:is-selected="{edge.selected}"
        on:click="{onEdgeClick(edge)}"
      ></line>
      {/if} {/each}
    </g>
    <g class="c-graph-network__nodes">
      {#each graph.nodes as node (node.id)}
      <g
        data-node-id="{node.id}"
        on:click="{onNodeClick(node)}"
        on:mousedown="{onNodeMouseDown(node)}"
      >
        <circle
          cx="{node.x}"
          cy="{node.y}"
          r="{radius}"
          class:is-selected="{node.selected}"
        ></circle>
        <text
          x="{node.x}"
          y="{node.y}"
          text-anchor="middle"
          alignment-baseline="middle"
        >
          {node.id}
        </text>
      </g>
      {/each}
    </g>
  </g>
</svg>

<svelte:options accessors></svelte:options>

<style>
  svg text {
    user-select: none;
  }

  .c-graph-network__nodes circle {
    stroke: #333;
    stroke-width: 2px;
    fill: dodgerblue;
  }

  .c-graph-network__nodes text {
    font-family: Arial, Helvetica, sans-serif;
    fill: black;
  }

  .c-graph-network__nodes .is-selected {
    stroke: orange;
  }

  .c-graph-network__edges path,
  .c-graph-network__edges line {
    stroke: #333;
    stroke-width: 2px;
    fill: transparent;
  }

  .c-graph-network__edges .is-selected {
    stroke: orange;
  }
</style>

<script>
  import { onMount, onDestroy, beforeUpdate } from 'svelte'
  import * as d3 from 'd3'

  import { createSimulation } from './simulation'
  import { seedNodes } from './seed'

  export let offsetX = 0
  export let offsetY = 0
  export let scale = 1

  let svg
  const radius = 20

  let graph = {
    nodes: [],
    edges: []
  }
  const selected = {
    nodes: [],
    edges: []
  }

  let simulation
  let nodeCounter = 0

  let noop = () => {}

  export let onSvgMouseDown = noop
  export let onSvgMouseMove = noop
  export let onSvgClick = noop
  export let onSvgMount = noop
  export let onSvgMouseWheel = noop

  export let onNodeClick = () => noop
  export let onNodeMouseDown = () => noop

  export let onEdgeClick = () => noop

  onMount(() => {
    simulation = createSimulation({
      width: svg.clientWidth,
      height: svg.clientHeight,
      radius
    })
    simulation.nodes(graph.nodes)
    simulation.force('link').links(graph.edges)

    simulation.on('tick', () => {
      graph.nodes = graph.nodes
      graph.edges = graph.edges
    })

    onSvgMount()
  })

  export function restartSimulation(alpha = 1) {
    simulation.nodes(graph.nodes)
    simulation.force('link').links(graph.edges)
    simulation.alpha(alpha)
    simulation.restart()
  }

  export function getWidth() {
    return svg.clientWidth
  }

  export function getHeight() {
    return svg.clientHeight
  }

  function curve(edge) {
    return `
      M ${edge.source.x} ${edge.source.y}
      Q
        ${edge.source.x / 2 +
          edge.target.x / 2 -
          edge.source.y / 3 +
          edge.target.y / 3}
        ${edge.source.y / 2 +
          edge.target.y / 2 -
          edge.target.x / 3 +
          edge.source.x / 3}
        ${edge.target.x} ${edge.target.y}
    `
  }

  function rotateVector(vector) {}

  export function createNodeAt(x, y) {
    nodeCounter = nodeCounter + 1
    graph.nodes.push({
      id: nodeCounter,
      x,
      y
    })
    graph.nodes = graph.nodes
    restartSimulation()
  }

  export function createEdge(sourceNode, targetNode) {
    if (
      !graph.edges.find(
        edge =>
          edge.source.id === sourceNode.id &&
          edge.target.id === targetNode.id
      )
    ) {
      const reverseEdge = graph.edges.find(
        e =>
          e.source.id === targetNode.id &&
          e.target.id === sourceNode.id
      )

      const edge = {
        id: `${sourceNode.id}-${targetNode.id}`,
        source: sourceNode,
        target: targetNode
      }

      if (reverseEdge) {
        edge.bidirect = true
        reverseEdge.bidirect = true
      }

      graph.edges.push(edge)
      graph.edges = graph.edges
      restartSimulation()
    }
  }

  export function selectNode(node) {
    if (!node.selected) {
      node.selected = true
      selected.nodes.push(node)
      graph.nodes = graph.nodes
    }
  }

  export function deselectNode(node) {
    if (node.selected) {
      node.selected = false

      const nodeIndex = selected.nodes.indexOf(node)
      if (nodeIndex !== -1) {
        selected.nodes.splice(nodeIndex, 1)
      }

      graph.nodes = graph.nodes
    }
  }

  export function getSelectedNodes() {
    return selected.nodes
  }

  export function selectEdge(edge) {
    edge.selected = true
    selected.edges.push(edge)
    graph.edges = graph.edges
  }

  export function deselectEdge(edge) {
    if (edge.selected) {
      edge.selected = false

      const edgeIndex = selected.edges.indexOf(edge)
      if (edgeIndex !== -1) {
        selected.edges.splice(edgeIndex, 1)
      }

      graph.edges = graph.edges
    }
  }

  export function getSelectedEdges() {
    return selected.edges
  }

  export function clearNodeSelections() {
    for (const node of selected.nodes) {
      node.selected = undefined
    }
    selected.nodes = []
    graph.nodes = graph.nodes
  }

  export function clearEdgeSelections() {
    for (const edge of selected.edges) {
      edge.selected = undefined
    }
    selected.edges = []
    graph.edges = graph.edges
  }

  export function clearSelections() {
    clearNodeSelections()
    clearEdgeSelections()
  }

  export function removeNode(node) {
    const nodeIndex = graph.nodes.indexOf(node)
    if (nodeIndex !== -1) {
      graph.nodes.splice(nodeIndex, 1)
      graph.nodes = graph.nodes

      graph.edges = graph.edges.filter(
        e => e.source.id !== node.id && e.target.id !== node.id
      )
      graph.edges = graph.edges

      restartSimulation()
    }
  }

  export function removeEdge(edge) {
    const edgeIndex = graph.edges.indexOf(edge)
    if (edgeIndex !== -1) {
      const reverseEdge = graph.edges.find(
        e =>
          e.source.id === edge.target.id &&
          e.target.id === edge.source.id
      )

      if (reverseEdge) {
        reverseEdge.bidirect = false
      }

      graph.edges.splice(edgeIndex, 1)
      graph.edges = graph.edges
      restartSimulation()
    }
  }

  export function getBoundingClientRect() {
    return svg.getBoundingClientRect()
  }

  export function isActive() {
    return simulation.alpha() > simulation.alphaMin()
  }

  export function update() {
    graph = graph
  }
</script>
